Rx основан на двух основных типах, в то время как несколько других расширяют функциональность вокруг основных типов. Эти два основных типа - Observableи Observer, которые будут представлены в этой главе. Мы также введем Subjects, которые облегчают кривую обучения.

Rx основывается на паттерне Observer . Это не уникально в этом. Обработка событий уже существует в Java (например, EventFandler JavaFX). Это более простые подходы, которые страдают по сравнению с Rx:

События через обработчики событий сложно составить.
Они не могут быть запрошены с течением времени
Они могут привести к утечкам памяти
Это не стандартный способ завершения сигнализации.
Требуется ручная обработка параллелизма и многопоточности.

Observable

Observable является первым ключевым элементом, который мы увидим.
 Этот класс содержит множество реализаций Rx, включая все основные операторы.
  Мы будем исследовать это шаг за шагом в этой книге. На данный момент мы должны понять
   Subscribe метод. Вот одна из ключевых перегрузок метода:

   public final Subscription subscribe(Subscriber<? super T> subscriber)

   Это метод, который вы используете для получения значений, испускаемых наблюдаемой.
    По мере продвижения значений (посредством политик, которые мы обсудим в этой книге),
    они передаются подписчику, который затем отвечает за поведение, намеченное потребителем.
     Subscriber Здесь является реализация Observer интерфейса.

   Наблюдаемые толчки 3 вида событий

   Ценности
   Завершение, которое указывает, что больше значений не будет передано.
   Ошибки, если что-то привело к сбою последовательности. Эти события также подразумевают прекращение.

Observer

Мы уже видели одну абстрактную реализацию наблюдателя , Subscriber. Subscriberреализует некоторую
 дополнительную функциональность и должна использоваться в качестве основы для наших реализаций
  Observer. На данный момент проще понять интерфейс.

interface Observer<T> {
    void onCompleted();
    void onError(java.lang.Throwable e);
    void onNext(T t);
}

Эти три метода - это поведение, которое выполняется каждый раз, когда наблюдаемое толкает значение.
 Наблюдатель будет иметь свой onNextвызываемый ноль или более раз, за ​​которыми может следовать
  onCompletedили или onError. Никаких звонков не происходит после звонка onErrorили onCompleted.

При разработке кода Rx вы увидите много Observable, но не так много Observer.
 В то время как важно понимать Observer, есть сокращения, которые устраняют необходимость
  создавать его сами.

  Реализация наблюдаемого и наблюдателя(Implementing Observable and Observer)

  Вы можете вручную реализовать Observerили расширить Observable. В действительности это обычно
   не требуется, поскольку Rx уже предоставляет все необходимые вам строительные блоки.
    Это также опасно, поскольку взаимодействие между частями Rx включает в себя условные
     обозначения и внутреннюю канализацию, которые не очевидны для новичка. Проще и безопаснее
      использовать множество инструментов, предоставляемых Rx, для создания необходимых вам функций.

  Чтобы подписаться на наблюдаемое, совсем не обязательно предоставлять экземпляры Observer.
   Существуют перегрузки, subscribeкоторые просто принимают функции, для которых они выполняются
    onNext, onErrorи onSubscribeскрывают создание соответствующих экземпляров Observer.
     Нет необходимости даже предоставлять каждую из этих функций. Вы можете предоставить
      подмножество их, то есть просто onNextили просто onNextи onError.

  Введение лямбда-функций в Java 1.8 делает эти перегрузки очень удобными для коротких примеров,
   существующих в этой книге.

Subject

Subjects являются расширением, Observable которое также реализует Observer интерфейс.
 Поначалу эта идея может показаться странной, но в некоторых случаях они значительно упрощают
  ситуацию. Им могут быть отправлены события (например, наблюдатели), которые они затем передают
   своим подписчикам (например, наблюдаемые). Это делает их идеальными точками входа в код Rx:
    когда у вас есть значения, поступающие извне Rx, вы можете поместить их в a Subject, превратив
     их в наблюдаемые. Вы можете думать о них как о точках входа в конвейер Rx.

Subject имеет два типа параметров: тип ввода и тип вывода. Это было разработано так ради абстракции,
 а не потому, что общее использование предметов включает в себя преобразование ценностей.
 Для этого есть операторы преобразования, которые мы увидим позже.

Есть несколько разных реализаций Subject. Сейчас мы рассмотрим наиболее важные из них и их различия.